import pandas as pdimport numpy as npimport kerasimport os from glob import  globfrom scipy import ndimage as ndimport torchfrom torch.utils.data import Dataset, DataLoaderimport torchvisionimport nibabel as nibsignal_file_name="amygdala"img=nib.load(f"./signals/{signal_file_name}.nii")signal=np.asanyarray(img.dataobj)exp_path=f"./resnet/{signal_file_name}"os.makedirs(exp_path,exist_ok=True)datapath=glob(("./export_data/**/*.npy"))lbl_dict={"healthy":1,"unhealthy":0}df=pd.DataFrame(datapath,columns=["path"])df["label"]=df["path"].apply(lambda x :lbl_dict[x.rsplit("/")[2]])# df=pd.read_csv("df.csv",index_col=0)# del datapathclass customDataset (Dataset):    def __init__(self,path_df,signal=None):        self.df=path_df        self.signal=signal        def __len__(self):        return(len(self.df))        def __getitem__(self,index):        path,lbl=self.df.iloc[index]        mri=np.load(path)        mri=mri+128        if self.signal is not None:              mri=np.expand_dims(self.signal,-1)*mri        mri=torch.tensor(mri,dtype=torch.float)        return(mri,lbl)                dataset=customDataset(df,signal)part_size=50resnet=torchvision.models.resnet18(weights='ResNet18_Weights.DEFAULT')length=dataset.__len__()for item in range(length):    mri,lbl=dataset.__getitem__(item)    times=mri.shape[-1]    imgs=[]    for time in range(times):        img=mri[:,:,:,time]        img=torch.tile(torch.unsqueeze(torch.permute(img,(1,0,2)),1),[1,3,1,1])        imgs.append(resnet(img))        print(f"item: {item}/{length} , step: {time}/{times}")        if (time+1)%part_size==0:            imgs=torch.vstack(imgs).reshape(-1,109,1000)            torch.save(imgs,f"{exp_path}/signal_{item}_part{int(time/part_size)}_{lbl}.pt")            imgs=[]    if imgs:        imgs=torch.vstack(imgs).reshape(-1,109,1000)        torch.save(imgs,f"{exp_path}/signal_{item}_part{int(time/part_size)}_{lbl}.pt")    print(f"item {item} Done!!!")            